# 백준 2563번 - 색종이
# 문제: 100x100 도화지에 10x10 색종이들을 붙였을 때 총 검은 영역의 넓이
# 다시 한 번 풀어보기

num = int(input())

# 100x100 도화지를 나타내는 2차원 배열 (0으로 초기화)
# 핵심 아이디어: 복잡한 겹침 계산 대신 좌표평면에 직접 표시하기
paper = [[0]*100 for _ in range(100)]

# 각 색종이마다 해당 영역을 1로 표시
for _ in range(num):
    x, y = map(int, input().split())
    
    # (x,y)는 색종이의 왼쪽 아래 좌표
    # 색종이는 (x,y)부터 (x+9, y+9)까지 차지 (range는 끝점 미포함이므로 x+10)
    for i in range(x, x+10):
        for j in range(y, y+10):
            paper[i][j] = 1  # 겹치는 부분도 자동으로 1로 유지됨 (중복 제거!)

# 1로 표시된 영역의 개수 세기
area = 0
for i in range(100):
    for j in range(100):
        if paper[i][j] == 1:
            area += 1

print(area)

"""
이전 실수들과 교훈:
1. 처음 접근: 수학적으로 겹치는 면적을 직접 계산하려 함
   - 문제점: 절댓값 처리(elif 순서), 3개 이상 겹침 미고려
   - 복잡하고 버그 발생 가능성 높음

2. 올바른 접근: 2차원 배열로 상태 표현
   - 장점: 직관적, 모든 겹침 자동 처리, 구현 간단
   - 시간복잡도: O(n*100) + O(10000) = 충분히 빠름

3. 핵심 깨달음: 
   - 복잡한 수학보다 단순한 시뮬레이션이 더 안전할 때가 많다
   - 좌표가 작을 때는 브루트포스가 효과적
   - "어려운 방법"이 항상 "좋은 방법"은 아니다
"""